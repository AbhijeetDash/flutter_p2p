// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: protos/protos.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// protoc --dart_out=./lib/gen ./protos/protos.proto
// protoc --swift_out=./ios/gen ./protos/protos.proto

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct StateChange {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var isEnabled: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct WifiP2pDevice {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var wpsPbcSupported: Bool = false

  var wpsKeypadSupported: Bool = false

  var wpsDisplaySupported: Bool = false

  var isServiceDiscoveryCapable: Bool = false

  var isGroupOwner: Bool = false

  var deviceName: String = String()

  var deviceAddress: String = String()

  var primaryDeviceType: String = String()

  var secondaryDeviceType: String = String()

  var status: WifiP2pDevice.Status = .connected

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Status: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case connected // = 0
    case invited // = 1
    case failed // = 2
    case available // = 3
    case unavailable // = 4
    case UNRECOGNIZED(Int)

    init() {
      self = .connected
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .connected
      case 1: self = .invited
      case 2: self = .failed
      case 3: self = .available
      case 4: self = .unavailable
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .connected: return 0
      case .invited: return 1
      case .failed: return 2
      case .available: return 3
      case .unavailable: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension WifiP2pDevice.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [WifiP2pDevice.Status] = [
    .connected,
    .invited,
    .failed,
    .available,
    .unavailable,
  ]
}

#endif  // swift(>=4.2)

struct WifiP2pDeviceList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var devices: [WifiP2pDevice] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ConnectionChange {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var wifiP2PInfo: WifiP2pInfo {
    get {return _storage._wifiP2PInfo ?? WifiP2pInfo()}
    set {_uniqueStorage()._wifiP2PInfo = newValue}
  }
  /// Returns true if `wifiP2PInfo` has been explicitly set.
  var hasWifiP2PInfo: Bool {return _storage._wifiP2PInfo != nil}
  /// Clears the value of `wifiP2PInfo`. Subsequent reads from it will return its default value.
  mutating func clearWifiP2PInfo() {_uniqueStorage()._wifiP2PInfo = nil}

  var networkInfo: NetworkInfo {
    get {return _storage._networkInfo ?? NetworkInfo()}
    set {_uniqueStorage()._networkInfo = newValue}
  }
  /// Returns true if `networkInfo` has been explicitly set.
  var hasNetworkInfo: Bool {return _storage._networkInfo != nil}
  /// Clears the value of `networkInfo`. Subsequent reads from it will return its default value.
  mutating func clearNetworkInfo() {_uniqueStorage()._networkInfo = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct WifiP2pInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var groupFormed: Bool = false

  var isGroupOwner: Bool = false

  var groupOwnerAddress: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct NetworkInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var subType: Int32 = 0

  var isConnected: Bool = false

  var detailedState: NetworkInfo.DetailedState = .idle

  var extraInfo: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum DetailedState: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case idle // = 0
    case scanning // = 1
    case connecting // = 2
    case authenticating // = 3
    case obtainingIpaddr // = 4
    case connected // = 5
    case suspended // = 6
    case disconnecting // = 7
    case disconnected // = 8
    case failed // = 9
    case blocked // = 10
    case verifyingPoorLink // = 11
    case captivePortalCheck // = 12
    case UNRECOGNIZED(Int)

    init() {
      self = .idle
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .idle
      case 1: self = .scanning
      case 2: self = .connecting
      case 3: self = .authenticating
      case 4: self = .obtainingIpaddr
      case 5: self = .connected
      case 6: self = .suspended
      case 7: self = .disconnecting
      case 8: self = .disconnected
      case 9: self = .failed
      case 10: self = .blocked
      case 11: self = .verifyingPoorLink
      case 12: self = .captivePortalCheck
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .idle: return 0
      case .scanning: return 1
      case .connecting: return 2
      case .authenticating: return 3
      case .obtainingIpaddr: return 4
      case .connected: return 5
      case .suspended: return 6
      case .disconnecting: return 7
      case .disconnected: return 8
      case .failed: return 9
      case .blocked: return 10
      case .verifyingPoorLink: return 11
      case .captivePortalCheck: return 12
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension NetworkInfo.DetailedState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [NetworkInfo.DetailedState] = [
    .idle,
    .scanning,
    .connecting,
    .authenticating,
    .obtainingIpaddr,
    .connected,
    .suspended,
    .disconnecting,
    .disconnected,
    .failed,
    .blocked,
    .verifyingPoorLink,
    .captivePortalCheck,
  ]
}

#endif  // swift(>=4.2)

struct RequestPermissionResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var requestCode: Int32 = 0

  var grantedPermissions: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SocketMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var port: Int32 = 0

  /// The number of bytes which are still available
  var dataAvailable: Int32 = 0

  /// The data
  var data: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension StateChange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StateChange"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "isEnabled"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.isEnabled)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.isEnabled != false {
      try visitor.visitSingularBoolField(value: self.isEnabled, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StateChange, rhs: StateChange) -> Bool {
    if lhs.isEnabled != rhs.isEnabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension WifiP2pDevice: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "WifiP2pDevice"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "wpsPbcSupported"),
    2: .same(proto: "wpsKeypadSupported"),
    3: .same(proto: "wpsDisplaySupported"),
    4: .same(proto: "isServiceDiscoveryCapable"),
    5: .same(proto: "isGroupOwner"),
    6: .same(proto: "deviceName"),
    7: .same(proto: "deviceAddress"),
    8: .same(proto: "primaryDeviceType"),
    9: .same(proto: "secondaryDeviceType"),
    10: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.wpsPbcSupported)
      case 2: try decoder.decodeSingularBoolField(value: &self.wpsKeypadSupported)
      case 3: try decoder.decodeSingularBoolField(value: &self.wpsDisplaySupported)
      case 4: try decoder.decodeSingularBoolField(value: &self.isServiceDiscoveryCapable)
      case 5: try decoder.decodeSingularBoolField(value: &self.isGroupOwner)
      case 6: try decoder.decodeSingularStringField(value: &self.deviceName)
      case 7: try decoder.decodeSingularStringField(value: &self.deviceAddress)
      case 8: try decoder.decodeSingularStringField(value: &self.primaryDeviceType)
      case 9: try decoder.decodeSingularStringField(value: &self.secondaryDeviceType)
      case 10: try decoder.decodeSingularEnumField(value: &self.status)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.wpsPbcSupported != false {
      try visitor.visitSingularBoolField(value: self.wpsPbcSupported, fieldNumber: 1)
    }
    if self.wpsKeypadSupported != false {
      try visitor.visitSingularBoolField(value: self.wpsKeypadSupported, fieldNumber: 2)
    }
    if self.wpsDisplaySupported != false {
      try visitor.visitSingularBoolField(value: self.wpsDisplaySupported, fieldNumber: 3)
    }
    if self.isServiceDiscoveryCapable != false {
      try visitor.visitSingularBoolField(value: self.isServiceDiscoveryCapable, fieldNumber: 4)
    }
    if self.isGroupOwner != false {
      try visitor.visitSingularBoolField(value: self.isGroupOwner, fieldNumber: 5)
    }
    if !self.deviceName.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceName, fieldNumber: 6)
    }
    if !self.deviceAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceAddress, fieldNumber: 7)
    }
    if !self.primaryDeviceType.isEmpty {
      try visitor.visitSingularStringField(value: self.primaryDeviceType, fieldNumber: 8)
    }
    if !self.secondaryDeviceType.isEmpty {
      try visitor.visitSingularStringField(value: self.secondaryDeviceType, fieldNumber: 9)
    }
    if self.status != .connected {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: WifiP2pDevice, rhs: WifiP2pDevice) -> Bool {
    if lhs.wpsPbcSupported != rhs.wpsPbcSupported {return false}
    if lhs.wpsKeypadSupported != rhs.wpsKeypadSupported {return false}
    if lhs.wpsDisplaySupported != rhs.wpsDisplaySupported {return false}
    if lhs.isServiceDiscoveryCapable != rhs.isServiceDiscoveryCapable {return false}
    if lhs.isGroupOwner != rhs.isGroupOwner {return false}
    if lhs.deviceName != rhs.deviceName {return false}
    if lhs.deviceAddress != rhs.deviceAddress {return false}
    if lhs.primaryDeviceType != rhs.primaryDeviceType {return false}
    if lhs.secondaryDeviceType != rhs.secondaryDeviceType {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension WifiP2pDevice.Status: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CONNECTED"),
    1: .same(proto: "INVITED"),
    2: .same(proto: "FAILED"),
    3: .same(proto: "AVAILABLE"),
    4: .same(proto: "UNAVAILABLE"),
  ]
}

extension WifiP2pDeviceList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "WifiP2pDeviceList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "devices"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.devices)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.devices.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.devices, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: WifiP2pDeviceList, rhs: WifiP2pDeviceList) -> Bool {
    if lhs.devices != rhs.devices {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ConnectionChange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ConnectionChange"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "wifiP2pInfo"),
    2: .same(proto: "networkInfo"),
  ]

  fileprivate class _StorageClass {
    var _wifiP2PInfo: WifiP2pInfo? = nil
    var _networkInfo: NetworkInfo? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _wifiP2PInfo = source._wifiP2PInfo
      _networkInfo = source._networkInfo
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._wifiP2PInfo)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._networkInfo)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._wifiP2PInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._networkInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ConnectionChange, rhs: ConnectionChange) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._wifiP2PInfo != rhs_storage._wifiP2PInfo {return false}
        if _storage._networkInfo != rhs_storage._networkInfo {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension WifiP2pInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "WifiP2pInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "groupFormed"),
    2: .same(proto: "isGroupOwner"),
    3: .same(proto: "groupOwnerAddress"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.groupFormed)
      case 2: try decoder.decodeSingularBoolField(value: &self.isGroupOwner)
      case 3: try decoder.decodeSingularStringField(value: &self.groupOwnerAddress)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.groupFormed != false {
      try visitor.visitSingularBoolField(value: self.groupFormed, fieldNumber: 1)
    }
    if self.isGroupOwner != false {
      try visitor.visitSingularBoolField(value: self.isGroupOwner, fieldNumber: 2)
    }
    if !self.groupOwnerAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.groupOwnerAddress, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: WifiP2pInfo, rhs: WifiP2pInfo) -> Bool {
    if lhs.groupFormed != rhs.groupFormed {return false}
    if lhs.isGroupOwner != rhs.isGroupOwner {return false}
    if lhs.groupOwnerAddress != rhs.groupOwnerAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NetworkInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "NetworkInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "subType"),
    2: .same(proto: "isConnected"),
    3: .same(proto: "detailedState"),
    4: .same(proto: "extraInfo"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.subType)
      case 2: try decoder.decodeSingularBoolField(value: &self.isConnected)
      case 3: try decoder.decodeSingularEnumField(value: &self.detailedState)
      case 4: try decoder.decodeSingularStringField(value: &self.extraInfo)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.subType != 0 {
      try visitor.visitSingularInt32Field(value: self.subType, fieldNumber: 1)
    }
    if self.isConnected != false {
      try visitor.visitSingularBoolField(value: self.isConnected, fieldNumber: 2)
    }
    if self.detailedState != .idle {
      try visitor.visitSingularEnumField(value: self.detailedState, fieldNumber: 3)
    }
    if !self.extraInfo.isEmpty {
      try visitor.visitSingularStringField(value: self.extraInfo, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NetworkInfo, rhs: NetworkInfo) -> Bool {
    if lhs.subType != rhs.subType {return false}
    if lhs.isConnected != rhs.isConnected {return false}
    if lhs.detailedState != rhs.detailedState {return false}
    if lhs.extraInfo != rhs.extraInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NetworkInfo.DetailedState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "IDLE"),
    1: .same(proto: "SCANNING"),
    2: .same(proto: "CONNECTING"),
    3: .same(proto: "AUTHENTICATING"),
    4: .same(proto: "OBTAINING_IPADDR"),
    5: .same(proto: "CONNECTED"),
    6: .same(proto: "SUSPENDED"),
    7: .same(proto: "DISCONNECTING"),
    8: .same(proto: "DISCONNECTED"),
    9: .same(proto: "FAILED"),
    10: .same(proto: "BLOCKED"),
    11: .same(proto: "VERIFYING_POOR_LINK"),
    12: .same(proto: "CAPTIVE_PORTAL_CHECK"),
  ]
}

extension RequestPermissionResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "RequestPermissionResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "requestCode"),
    2: .same(proto: "grantedPermissions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.requestCode)
      case 2: try decoder.decodeRepeatedStringField(value: &self.grantedPermissions)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.requestCode != 0 {
      try visitor.visitSingularInt32Field(value: self.requestCode, fieldNumber: 1)
    }
    if !self.grantedPermissions.isEmpty {
      try visitor.visitRepeatedStringField(value: self.grantedPermissions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RequestPermissionResult, rhs: RequestPermissionResult) -> Bool {
    if lhs.requestCode != rhs.requestCode {return false}
    if lhs.grantedPermissions != rhs.grantedPermissions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SocketMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SocketMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "port"),
    2: .same(proto: "dataAvailable"),
    3: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.port)
      case 2: try decoder.decodeSingularInt32Field(value: &self.dataAvailable)
      case 3: try decoder.decodeSingularBytesField(value: &self.data)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.port != 0 {
      try visitor.visitSingularInt32Field(value: self.port, fieldNumber: 1)
    }
    if self.dataAvailable != 0 {
      try visitor.visitSingularInt32Field(value: self.dataAvailable, fieldNumber: 2)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SocketMessage, rhs: SocketMessage) -> Bool {
    if lhs.port != rhs.port {return false}
    if lhs.dataAvailable != rhs.dataAvailable {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
